{"version":3,"file":"chunks/22711.a5e23b4d91852071538a.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/prosemirror-tables/dist/index.js","webpack://@patternslib/patternslib/./node_modules/@tiptap/extension-table/dist/index.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/extensions/table.js"],"sourcesContent":["// src/index.ts\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\n\n// src/cellselection.ts\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport {\n  NodeSelection as NodeSelection2,\n  Selection,\n  SelectionRange,\n  TextSelection\n} from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */ new WeakMap();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key) return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos) continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return { left, top, right, bottom };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    const { left, right, top, bottom } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0; ; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\")\n    throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table), height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n      if (i == rowNode.childCount) break;\n      const cellNode = rowNode.child(i);\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: \"collision\",\n              row,\n              pos,\n              n: colspan - w\n            });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: \"missing\", row, n: missing });\n    pos++;\n  }\n  if (width === 0 || height === 0)\n    (problems || (problems = [])).push({ type: \"zero_sized\" });\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        const prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          const cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n    if (width == -1) width = rowWidth;\n    else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: \"colwidth mismatch\",\n        pos,\n        colwidth: updated\n      });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n  return result;\n}\n\n// src/util.ts\nimport { PluginKey } from \"prosemirror-state\";\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter) setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: { default: 1 },\n    rowspan: { default: 1 },\n    colwidth: { default: null }\n  };\n  for (const prop in extraAttrs)\n    cellAttrs[prop] = { default: extraAttrs[prop].default };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: \"table\" }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{ tag: \"tr\" }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"td\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"th\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name], role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == \"row\")\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\") return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == \"row\") return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan - n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0)) result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan + n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class _CellSelection extends Selection {\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween(\n      $anchorCell.pos - tableStart,\n      $headCell.pos - tableStart\n    );\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map((pos) => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size)\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return _CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return _CellSelection.colSelection($anchorCell, $headCell);\n      else return new _CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(\n      this.$anchorCell.pos - tableStart,\n      this.$headCell.pos - tableStart\n    );\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(\n              attrs,\n              attrs.colspan - extraRight,\n              extraRight\n            );\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`\n              );\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n  replace(tr, content = Slice.empty) {\n    const mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? Slice.empty : content\n      );\n    }\n    const sel = Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1\n    );\n    if (sel) tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(\n      map.rectBetween(\n        this.$anchorCell.pos - tableStart,\n        this.$headCell.pos - tableStart\n      )\n    );\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[anchorRect.top * map.width]\n        );\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (headRect.top + 1) - 1]\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new _CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new _CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nSelection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class _CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))\n      return new CellSelection($anchorCell, $headCell);\n    else return Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" })\n    );\n  });\n  return DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({ $from, $to }) {\n  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth)) break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d)) break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount, curSize = cur.childCount;\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    const child = cur.child(i);\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child))\n      changedDescendants(old.child(j), child, offset + 1, f);\n    else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\")\n      tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState) state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)\n      );\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    } else if (prob.type == \"zero_sized\") {\n      const pos = tr.mapping.map(tablePos);\n      tr.delete(pos, pos + table.nodeSize);\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null) first = i;\n      last = i;\n    }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node) nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n\n// src/input.ts\nimport { keydownHandler } from \"prosemirror-keymap\";\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\nimport {\n  Selection as Selection2,\n  TextSelection as TextSelection3\n} from \"prosemirror-state\";\n\n// src/commands.ts\nimport {\n  Fragment as Fragment2,\n  Slice as Slice2\n} from \"prosemirror-model\";\nimport {\n  TextSelection as TextSelection2\n} from \"prosemirror-state\";\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(\n    sel.$anchorCell.pos - tableStart,\n    sel.$headCell.pos - tableStart\n  ) : map.findCell($pos.pos - tableStart);\n  return { ...rect, tableStart, map, table };\n}\nfunction addColumn(tr, { map, tableStart, table }, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs, col - map.colCount(pos))\n      );\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, { map, table, tableStart }, col) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(attrs, col - map.colCount(pos))\n      );\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)\n      return false;\n  return true;\n}\nfunction addRow(tr, { map, tableStart, table }, row) {\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node) cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, { map, table, tableStart }, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  const seen = /* @__PURE__ */ new Set();\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (seen.has(pos)) continue;\n    seen.add(pos);\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.height && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create(\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\n        cell.content\n      );\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state), tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)\n    return false;\n  const rect = selectedRect(state), { map } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = Fragment2.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell) continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(\n        mergedCell.attrs,\n        mergedCell.attrs.colspan,\n        rect.right - rect.left - mergedCell.attrs.colspan\n      ),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))\n    );\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };\n      if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };\n      const rect = selectedRect(state), tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth ? {\n            ...baseAttrs,\n            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n          } : baseAttrs\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(\n            lastCell = tr.mapping.map(pos + rect.tableStart, 1),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0]\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell ? tr.doc.resolve(lastCell) : void 0\n          )\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, {\n              ...node.attrs,\n              [name]: value\n            });\n        });\n      else\n        tr.setNodeMarkup($cell.pos, null, {\n          ...$cell.nodeAfter.attrs,\n          [name]: value\n        });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const cells = rect.map.cellsInRect(\n        type == \"column\" ? {\n          left: rect.left,\n          top: 0,\n          right: rect.right,\n          bottom: rect.map.height\n        } : type == \"row\" ? {\n          left: 0,\n          top: rect.top,\n          right: rect.map.width,\n          bottom: rect.bottom\n        } : rect\n      );\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++)\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs\n          );\n      if (tr.steps.length == 0)\n        for (let i = 0; i < cells.length; i++)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\n        \"column\",\n        rect,\n        types\n      );\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr.setSelection(TextSelection2.between($cell, moveCellForward($cell))).scrollIntoView()\n      );\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()\n        );\n      return true;\n    }\n  }\n  return false;\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new Slice2(baseContent, 0, 0)\n        );\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n  return true;\n}\n\n// src/copypaste.ts\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nfunction pastedCells(slice) {\n  if (!slice.size) return null;\n  let { content, openStart, openEnd } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema, rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new Slice3(cells, left, right)\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(\n      openStart || openEnd ? fitSlice(\n        tableNodeTypes(schema).row,\n        new Slice3(content, openStart, openEnd)\n      ).content : content\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment3.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment3.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row], cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.createChecked(\n            removeColSpan(\n              cell.attrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth\n            ),\n            cell.content\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment3.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [], source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            {\n              ...cell.attrs,\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n            },\n            cell.content\n          );\n        cells.push(cell);\n      }\n      newRows.push(Fragment3.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return { width, height, rows };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill());\n      else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++) cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(\n        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())\n      );\n    }\n    const emptyRow = types.row.create(null, Fragment3.from(cells)), rows = [];\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col, pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill({\n          ...cell.attrs,\n          rowspan: cellTop + cell.attrs.rowspan - top\n        })\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left, pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft)\n        )\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(\n          removeColSpan(cell.attrs, 0, left - cellLeft)\n        )\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const { top, left } = rect;\n  const right = left + cells.width, bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new Slice3(cells.rows[row - top], 0, 0)\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))\n    )\n  );\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = keydownHandler({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(sel.$headCell, dir)\n      );\n    }\n    if (axis != \"horiz\" && !sel.empty) return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(state.doc.resolve(sel.head + dir), dir)\n      );\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next) newSel = Selection2.near($next, 1);\n      else if (dir < 0)\n        newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);\n      else newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(cellSel.$anchorCell, $head)\n    );\n  };\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          Fragment4.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice)\n          )\n        ]\n      };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting) $head = $anchor2;\n      else return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2) return stop();\n    }\n    if ($anchor2) setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection3)) return null;\n  const { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos) return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\nimport {\n  Decoration as Decoration2,\n  DecorationSet as DecorationSet2\n} from \"prosemirror-view\";\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, defaultCellMinWidth) {\n    this.node = node;\n    this.defaultCellMinWidth = defaultCellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.table.style.setProperty(\n      \"--default-cell-min-width\",\n      `${defaultCellMinWidth}px`\n    );\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumnsOnResize(\n      node,\n      this.colgroup,\n      this.table,\n      this.defaultCellMinWidth\n    );\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row) return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const { colspan, colwidth } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || defaultCellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n      if (!nextDOM) {\n        const col2 = document.createElement(\"col\");\n        col2.style.width = cssWidth;\n        colgroup.appendChild(col2);\n      } else {\n        if (nextDOM.style.width != cssWidth) {\n          nextDOM.style.width = cssWidth;\n        }\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new PluginKey3(\n  \"tableColumnResizing\"\n);\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  defaultCellMinWidth = 100,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  const plugin = new Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        var _a, _b;\n        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;\n        const tableName = tableNodeTypes(state.schema).table.name;\n        if (View && nodeViews) {\n          nodeViews[tableName] = (node, view) => {\n            return new View(node, defaultCellMinWidth, view);\n          };\n        }\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(view, event, handleWidth, lastColumnResizable);\n        },\n        mouseleave: (view) => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);\n        }\n      },\n      decorations: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class _ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null)\n      return new _ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0)\n      return new _ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new _ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, lastColumnResizable) {\n  if (!view.editable) return;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState) return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, \"left\", handleWidth);\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, \"right\", handleWidth);\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  if (!view.editable) return;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {\n  var _a;\n  if (!view.editable) return false;\n  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\n    return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, {\n      setDragging: { startX: event.clientX, startWidth: width }\n    })\n  );\n  function finish(event2) {\n    win.removeEventListener(\"mouseup\", finish);\n    win.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        draggedWidth(pluginState2.dragging, event2, cellMinWidth)\n      );\n      view.dispatch(\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })\n      );\n    }\n  }\n  function move(event2) {\n    if (!event2.which) return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2) return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        dragged,\n        defaultCellMinWidth\n      );\n    }\n  }\n  displayColumnWidth(\n    view,\n    pluginState.activeHandle,\n    width,\n    defaultCellMinWidth\n  );\n  win.addEventListener(\"mouseup\", finish);\n  win.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth, parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY\n  });\n  if (!found) return -1;\n  const { pos } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == \"right\") return $cell.pos;\n  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, resizeMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(resizeMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })\n  );\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });\n  }\n  if (tr.docChanged) view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, defaultCellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom) return;\n  updateColumnsOnResize(\n    table,\n    dom.firstChild,\n    dom,\n    defaultCellMinWidth,\n    col,\n    width\n  );\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  var _a;\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet2.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width;\n    if ((col == map.width - 1 || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      if ((_a = columnResizingPluginKey.getState(state)) == null ? void 0 : _a.dragging) {\n        decorations.push(\n          Decoration2.node(\n            start + cellPos,\n            start + cellPos + table.nodeAt(cellPos).nodeSize,\n            {\n              class: \"column-resize-dragging\"\n            }\n          )\n        );\n      }\n      decorations.push(Decoration2.widget(pos, dom));\n    }\n  }\n  return DecorationSet2.create(state.doc, decorations);\n}\n\n// src/index.ts\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new Plugin2({\n    key: tableEditingKey,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        const { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection\n      );\n    }\n  });\n}\nexport {\n  CellBookmark,\n  CellSelection,\n  ResizeState,\n  TableMap,\n  TableView,\n  clipCells as __clipCells,\n  insertCells as __insertCells,\n  pastedCells as __pastedCells,\n  addColSpan,\n  addColumn,\n  addColumnAfter,\n  addColumnBefore,\n  addRow,\n  addRowAfter,\n  addRowBefore,\n  cellAround,\n  cellNear,\n  colCount,\n  columnIsHeader,\n  columnResizing,\n  columnResizingPluginKey,\n  deleteCellSelection,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  findCell,\n  fixTables,\n  fixTablesKey,\n  goToNextCell,\n  handlePaste,\n  inSameTable,\n  isInTable,\n  mergeCells,\n  moveCellForward,\n  nextCell,\n  pointsAtCell,\n  removeColSpan,\n  removeColumn,\n  removeRow,\n  rowIsHeader,\n  selectedRect,\n  selectionCell,\n  setCellAttr,\n  splitCell,\n  splitCellWithType,\n  tableEditing,\n  tableEditingKey,\n  tableNodeTypes,\n  tableNodes,\n  toggleHeader,\n  toggleHeaderCell,\n  toggleHeaderColumn,\n  toggleHeaderRow,\n  updateColumnsOnResize\n};\n","import { findParentNodeClosestToPos, Node, mergeAttributes, callOrReturn, getExtensionField } from '@tiptap/core';\nimport { TextSelection } from '@tiptap/pm/state';\nimport { CellSelection, addColumnBefore, addColumnAfter, deleteColumn, addRowBefore, addRowAfter, deleteRow, deleteTable, mergeCells, splitCell, toggleHeader, toggleHeaderCell, setCellAttr, goToNextCell, fixTables, columnResizing, tableEditing } from '@tiptap/pm/tables';\n\nfunction getColStyleDeclaration(minWidth, width) {\n    if (width) {\n        // apply the stored width unless it is below the configured minimum cell width\n        return ['width', `${Math.max(width, minWidth)}px`];\n    }\n    // set the minimum with on the column if it has no stored width\n    return ['min-width', `${minWidth}px`];\n}\n\nfunction updateColumns(node, colgroup, // <colgroup> has the same prototype as <col>\ntable, cellMinWidth, overrideCol, overrideValue) {\n    var _a;\n    let totalWidth = 0;\n    let fixedWidth = true;\n    let nextDOM = colgroup.firstChild;\n    const row = node.firstChild;\n    if (row !== null) {\n        for (let i = 0, col = 0; i < row.childCount; i += 1) {\n            const { colspan, colwidth } = row.child(i).attrs;\n            for (let j = 0; j < colspan; j += 1, col += 1) {\n                const hasWidth = overrideCol === col ? overrideValue : (colwidth && colwidth[j]);\n                const cssWidth = hasWidth ? `${hasWidth}px` : '';\n                totalWidth += hasWidth || cellMinWidth;\n                if (!hasWidth) {\n                    fixedWidth = false;\n                }\n                if (!nextDOM) {\n                    const colElement = document.createElement('col');\n                    const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth);\n                    colElement.style.setProperty(propertyKey, propertyValue);\n                    colgroup.appendChild(colElement);\n                }\n                else {\n                    if (nextDOM.style.width !== cssWidth) {\n                        const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth);\n                        nextDOM.style.setProperty(propertyKey, propertyValue);\n                    }\n                    nextDOM = nextDOM.nextSibling;\n                }\n            }\n        }\n    }\n    while (nextDOM) {\n        const after = nextDOM.nextSibling;\n        (_a = nextDOM.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(nextDOM);\n        nextDOM = after;\n    }\n    if (fixedWidth) {\n        table.style.width = `${totalWidth}px`;\n        table.style.minWidth = '';\n    }\n    else {\n        table.style.width = '';\n        table.style.minWidth = `${totalWidth}px`;\n    }\n}\nclass TableView {\n    constructor(node, cellMinWidth) {\n        this.node = node;\n        this.cellMinWidth = cellMinWidth;\n        this.dom = document.createElement('div');\n        this.dom.className = 'tableWrapper';\n        this.table = this.dom.appendChild(document.createElement('table'));\n        this.colgroup = this.table.appendChild(document.createElement('colgroup'));\n        updateColumns(node, this.colgroup, this.table, cellMinWidth);\n        this.contentDOM = this.table.appendChild(document.createElement('tbody'));\n    }\n    update(node) {\n        if (node.type !== this.node.type) {\n            return false;\n        }\n        this.node = node;\n        updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\n        return true;\n    }\n    ignoreMutation(mutation) {\n        return (mutation.type === 'attributes'\n            && (mutation.target === this.table || this.colgroup.contains(mutation.target)));\n    }\n}\n\nfunction createColGroup(node, cellMinWidth, overrideCol, overrideValue) {\n    let totalWidth = 0;\n    let fixedWidth = true;\n    const cols = [];\n    const row = node.firstChild;\n    if (!row) {\n        return {};\n    }\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\n        const { colspan, colwidth } = row.child(i).attrs;\n        for (let j = 0; j < colspan; j += 1, col += 1) {\n            const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];\n            totalWidth += hasWidth || cellMinWidth;\n            if (!hasWidth) {\n                fixedWidth = false;\n            }\n            const [property, value] = getColStyleDeclaration(cellMinWidth, hasWidth);\n            cols.push([\n                'col',\n                { style: `${property}: ${value}` },\n            ]);\n        }\n    }\n    const tableWidth = fixedWidth ? `${totalWidth}px` : '';\n    const tableMinWidth = fixedWidth ? '' : `${totalWidth}px`;\n    const colgroup = ['colgroup', {}, ...cols];\n    return { colgroup, tableWidth, tableMinWidth };\n}\n\nfunction createCell(cellType, cellContent) {\n    if (cellContent) {\n        return cellType.createChecked(null, cellContent);\n    }\n    return cellType.createAndFill();\n}\n\nfunction getTableNodeTypes(schema) {\n    if (schema.cached.tableNodeTypes) {\n        return schema.cached.tableNodeTypes;\n    }\n    const roles = {};\n    Object.keys(schema.nodes).forEach(type => {\n        const nodeType = schema.nodes[type];\n        if (nodeType.spec.tableRole) {\n            roles[nodeType.spec.tableRole] = nodeType;\n        }\n    });\n    schema.cached.tableNodeTypes = roles;\n    return roles;\n}\n\nfunction createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {\n    const types = getTableNodeTypes(schema);\n    const headerCells = [];\n    const cells = [];\n    for (let index = 0; index < colsCount; index += 1) {\n        const cell = createCell(types.cell, cellContent);\n        if (cell) {\n            cells.push(cell);\n        }\n        if (withHeaderRow) {\n            const headerCell = createCell(types.header_cell, cellContent);\n            if (headerCell) {\n                headerCells.push(headerCell);\n            }\n        }\n    }\n    const rows = [];\n    for (let index = 0; index < rowsCount; index += 1) {\n        rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));\n    }\n    return types.table.createChecked(null, rows);\n}\n\nfunction isCellSelection(value) {\n    return value instanceof CellSelection;\n}\n\nconst deleteTableWhenAllCellsSelected = ({ editor }) => {\n    const { selection } = editor.state;\n    if (!isCellSelection(selection)) {\n        return false;\n    }\n    let cellCount = 0;\n    const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\n        return node.type.name === 'table';\n    });\n    table === null || table === void 0 ? void 0 : table.node.descendants(node => {\n        if (node.type.name === 'table') {\n            return false;\n        }\n        if (['tableCell', 'tableHeader'].includes(node.type.name)) {\n            cellCount += 1;\n        }\n    });\n    const allCellsSelected = cellCount === selection.ranges.length;\n    if (!allCellsSelected) {\n        return false;\n    }\n    editor.commands.deleteTable();\n    return true;\n};\n\n/**\n * This extension allows you to create tables.\n * @see https://www.tiptap.dev/api/nodes/table\n */\nconst Table = Node.create({\n    name: 'table',\n    // @ts-ignore\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n            resizable: false,\n            handleWidth: 5,\n            cellMinWidth: 25,\n            // TODO: fix\n            View: TableView,\n            lastColumnResizable: true,\n            allowTableNodeSelection: false,\n        };\n    },\n    content: 'tableRow+',\n    tableRole: 'table',\n    isolating: true,\n    group: 'block',\n    parseHTML() {\n        return [{ tag: 'table' }];\n    },\n    renderHTML({ node, HTMLAttributes }) {\n        const { colgroup, tableWidth, tableMinWidth } = createColGroup(node, this.options.cellMinWidth);\n        const table = [\n            'table',\n            mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n                style: tableWidth\n                    ? `width: ${tableWidth}`\n                    : `min-width: ${tableMinWidth}`,\n            }),\n            colgroup,\n            ['tbody', 0],\n        ];\n        return table;\n    },\n    addCommands() {\n        return {\n            insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {\n                const node = createTable(editor.schema, rows, cols, withHeaderRow);\n                if (dispatch) {\n                    const offset = tr.selection.from + 1;\n                    tr.replaceSelectionWith(node)\n                        .scrollIntoView()\n                        .setSelection(TextSelection.near(tr.doc.resolve(offset)));\n                }\n                return true;\n            },\n            addColumnBefore: () => ({ state, dispatch }) => {\n                return addColumnBefore(state, dispatch);\n            },\n            addColumnAfter: () => ({ state, dispatch }) => {\n                return addColumnAfter(state, dispatch);\n            },\n            deleteColumn: () => ({ state, dispatch }) => {\n                return deleteColumn(state, dispatch);\n            },\n            addRowBefore: () => ({ state, dispatch }) => {\n                return addRowBefore(state, dispatch);\n            },\n            addRowAfter: () => ({ state, dispatch }) => {\n                return addRowAfter(state, dispatch);\n            },\n            deleteRow: () => ({ state, dispatch }) => {\n                return deleteRow(state, dispatch);\n            },\n            deleteTable: () => ({ state, dispatch }) => {\n                return deleteTable(state, dispatch);\n            },\n            mergeCells: () => ({ state, dispatch }) => {\n                return mergeCells(state, dispatch);\n            },\n            splitCell: () => ({ state, dispatch }) => {\n                return splitCell(state, dispatch);\n            },\n            toggleHeaderColumn: () => ({ state, dispatch }) => {\n                return toggleHeader('column')(state, dispatch);\n            },\n            toggleHeaderRow: () => ({ state, dispatch }) => {\n                return toggleHeader('row')(state, dispatch);\n            },\n            toggleHeaderCell: () => ({ state, dispatch }) => {\n                return toggleHeaderCell(state, dispatch);\n            },\n            mergeOrSplit: () => ({ state, dispatch }) => {\n                if (mergeCells(state, dispatch)) {\n                    return true;\n                }\n                return splitCell(state, dispatch);\n            },\n            setCellAttribute: (name, value) => ({ state, dispatch }) => {\n                return setCellAttr(name, value)(state, dispatch);\n            },\n            goToNextCell: () => ({ state, dispatch }) => {\n                return goToNextCell(1)(state, dispatch);\n            },\n            goToPreviousCell: () => ({ state, dispatch }) => {\n                return goToNextCell(-1)(state, dispatch);\n            },\n            fixTables: () => ({ state, dispatch }) => {\n                if (dispatch) {\n                    fixTables(state);\n                }\n                return true;\n            },\n            setCellSelection: position => ({ tr, dispatch }) => {\n                if (dispatch) {\n                    const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);\n                    // @ts-ignore\n                    tr.setSelection(selection);\n                }\n                return true;\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            Tab: () => {\n                if (this.editor.commands.goToNextCell()) {\n                    return true;\n                }\n                if (!this.editor.can().addRowAfter()) {\n                    return false;\n                }\n                return this.editor.chain().addRowAfter().goToNextCell().run();\n            },\n            'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\n            Backspace: deleteTableWhenAllCellsSelected,\n            'Mod-Backspace': deleteTableWhenAllCellsSelected,\n            Delete: deleteTableWhenAllCellsSelected,\n            'Mod-Delete': deleteTableWhenAllCellsSelected,\n        };\n    },\n    addProseMirrorPlugins() {\n        const isResizable = this.options.resizable && this.editor.isEditable;\n        return [\n            ...(isResizable\n                ? [\n                    columnResizing({\n                        handleWidth: this.options.handleWidth,\n                        cellMinWidth: this.options.cellMinWidth,\n                        defaultCellMinWidth: this.options.cellMinWidth,\n                        View: this.options.View,\n                        lastColumnResizable: this.options.lastColumnResizable,\n                    }),\n                ]\n                : []),\n            tableEditing({\n                allowTableNodeSelection: this.options.allowTableNodeSelection,\n            }),\n        ];\n    },\n    extendNodeSchema(extension) {\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n        };\n        return {\n            tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\n        };\n    },\n});\n\nexport { Table, TableView, createColGroup, createTable, Table as default, updateColumns };\n//# sourceMappingURL=index.js.map\n","import { mergeAttributes } from \"@tiptap/core\";\nimport { Table as TipTapTable } from \"@tiptap/extension-table\";\n\nexport const factory = () => {\n    return TipTapTable.extend({\n        parseHTML() {\n            return [\n                {\n                    tag: \"table\",\n                    getAttrs: (node) =>\n                        node.closest(\"div.scroll-table\") === null && null,\n                },\n                {\n                    tag: \"div\",\n                    getAttrs: (node) =>\n                        node.querySelector(\".scroll-table > table\") ? null : false,\n                },\n            ];\n        },\n        renderHTML({ HTMLAttributes }) {\n            return [\n                \"div\",\n                { class: \"scroll-table\" },\n                [\n                    \"table\",\n                    mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n                    0,\n                ],\n            ];\n        },\n    });\n};\n"],"names":["readFromCache","addToCache","WeakMap","cache","key","get","value","set","cacheSize","cachePos","i","length","TableMap","constructor","width","height","map","problems","this","findCell","pos","curPos","left","top","right","bottom","j","RangeError","colCount","nextCell","axis","dir","rectBetween","a","b","leftA","rightA","topA","bottomA","leftB","rightB","topB","bottomB","Math","min","max","cellsInRect","rect","result","seen","row","col","index","push","positionAt","table","rowStart","rowEnd","child","nodeSize","rowEndIndex","type","spec","tableRole","name","hasRowSpan","childCount","rowNode","rowWidth","prevRow","cell","attrs","rowspan","colspan","findWidth","mapPos","colWidths","e","cellNode","colwidth","h","n","start","w","colW","widthIndex","prev","expectedPos","missing","tableMap","badWidths","node","nodeAt","updated","colWidth","freshColWidth","unshift","findBadColWidths","computeMap","slice","tableNodeTypes","schema","cached","nodes","role","tableEditingKey","cellAround","$pos","d","depth","resolve","before","isInTable","state","$head","selection","selectionCell","sel","$anchorCell","$headCell","$anchor","$cell","after","nodeAfter","firstChild","doc","nodeBefore","lastChild","cellNear","head","pointsAtCell","parent","inSameTable","$cellA","$cellB","end","tableStart","moved","removeColSpan","splice","some","addColSpan","CellSelection","_CellSelection","cells","filter","p","ranges","from","content","size","super","$from","$to","mapping","tableChanged","isRowSelection","rowSelection","isColSelection","colSelection","between","rows","rowContent","cellRect","extraLeft","extraRight","createAndFill","JSON","stringify","create","copy","fragment","replace","tr","empty","mapFrom","steps","findFrom","to","setSelection","replaceWith","forEachCell","f","anchorTop","headTop","anchorBottom","headBottom","anchorRect","headRect","anchorLeft","headLeft","anchorRight","headRight","eq","other","toJSON","anchor","fromJSON","json","anchorCell","headCell","getBookmark","CellBookmark","prototype","visible","jsonID","_CellBookmark","near","drawCellSelection","class","fixTablesKey","changedDescendants","old","cur","offset","oldSize","curSize","outer","scan","sameMarkup","nodesBetween","fixTables","oldState","check","tablePos","mustAdd","prob","setNodeMarkup","delete","first","last","add","side","insert","setMeta","fixTable","descendants","selectedRect","addColumn","refColumn","headerCell","header_cell","columnIsHeader","removeColumn","mapStart","maps","addRow","_a","rowPos","refRow","rowIsHeader","removeRow","nextRow","Set","has","newPos","isEmpty","c","isTextblock","mergeCells","dispatch","indexTop","indexLeft","indexBottom","indexRight","cellsOverlapRectangle","mergedPos","mergedCell","cellPos","append","mapped","splitCell","nodeTypes","getCellType","cellWrapping","baseAttrs","lastCell","isHeaderEnabledByType","types","cellPositions","toggleHeader","options","useDeprecatedLogic","deprecated_toggleHeader","isHeaderRowEnabled","isHeaderColumnEnabled","selectionStartsAt","cellsRect","newType","forEach","relativeCellPos","toggleHeaderCell","goToNextCell","direction","indexAfter","findNextCell","scrollIntoView","deleteCellSelection","baseContent","docChanged","pastedCells","openStart","openEnd","fitSlice","widths","r","ensureRectangular","nodeType","isolateHorizontal","found","cellTop","cellLeft","isolateVertical","updatePos","insertCells","Error","recomp","emptyHead","start2","header","emptyRow","growTable","handleKeyDown","ArrowLeft","arrow","ArrowRight","ArrowUp","ArrowDown","shiftArrow","Backspace","Delete","maybeSetSelection","view","atEndOfCell","$next","newSel","cellSel","handleTripleClick","handlePaste","_","newWidth","newHeight","added","newRows","frag","createChecked","source","clipCells","handleMouseDown","startEvent","ctrlKey","metaKey","startDOMCell","domInCell","target","shiftKey","setCellSelection","preventDefault","cellUnderMouse","$anchor2","event","starting","getState","stop","root","removeEventListener","move","_event","addEventListener","dirStr","endOfTextblock","dom","parentNode","nodeName","mousePos","posAtCoords","clientX","clientY","TableView","defaultCellMinWidth","document","createElement","className","appendChild","style","setProperty","colgroup","updateColumnsOnResize","contentDOM","update","ignoreMutation","record","contains","overrideCol","overrideValue","totalWidth","fixedWidth","nextDOM","hasWidth","cssWidth","nextSibling","col2","removeChild","minWidth","columnResizingPluginKey","columnResizing","handleWidth","cellMinWidth","View","lastColumnResizable","plugin","init","_b","nodeViews","props","tableName","ResizeState","apply","attributes","pluginState","activeHandle","handleDOMEvents","mousemove","editable","dragging","classList","domCellAround","getBoundingClientRect","edgeCell","updateHandle","handleMouseMove","mouseleave","handleMouseLeave","mousedown","win","ownerDocument","defaultView","window","domAtPos","domWidth","childNodes","offsetWidth","parts","currentColWidth","finish","event2","pluginState2","mapIndex","zeroes","updateColumnWidth","draggedWidth","setDragging","which","dragged","displayColumnWidth","startX","startWidth","handleMouseDown2","decorations","widget","handleDecorations","_ResizeState","action","getMeta","setHandle","handle","indexOf","resizeMinWidth","Array","fill","tableEditing","allowTableNodeSelection","deleted","mapResult","createSelectionBetween","appendTransaction","normalize","afterFrom","beforeTo","test","isCellBoundarySelection","fromCellBoundaryNode","toCellBoundaryNode","parentOffset","isTextSelectionAcrossCells","normalizeSelection","getColStyleDeclaration","updateColumns","propertyKey","propertyValue","colElement","mutation","createCell","cellType","cellContent","createTable","rowsCount","colsCount","withHeaderRow","roles","Object","keys","getTableNodeTypes","headerCells","deleteTableWhenAllCellsSelected","editor","cellCount","findParentNodeClosestToPos","includes","commands","deleteTable","Table","Node","addOptions","HTMLAttributes","resizable","isolating","group","parseHTML","tag","renderHTML","tableWidth","tableMinWidth","cols","property","createColGroup","mergeAttributes","addCommands","insertTable","replaceSelectionWith","addColumnBefore","addColumnAfter","deleteColumn","addRowBefore","addRowAfter","deleteRow","toggleHeaderColumn","toggleHeaderRow","mergeOrSplit","setCellAttribute","setCellAttr","goToPreviousCell","position","addKeyboardShortcuts","Tab","can","chain","run","addProseMirrorPlugins","isEditable","extendNodeSchema","extension","context","storage","callOrReturn","getExtensionField","factory","TipTapTable","extend","getAttrs","closest","querySelector","_ref"],"sourceRoot":""}